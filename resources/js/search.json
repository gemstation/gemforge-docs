[[{"l":"Introduction","p":["Gemforge is an open-source command-line tool for building, deploying and upgrading Diamond Standard contracts on EVM chains."]},{"l":"Why","p":["The Diamond Standard (EIP-2535) is one of the best ways to build and deploy infinite sized, upgradeable contracts.","But utilizing the standard involves having to write a lot of boilerplate code, including but not limited to the core diamond proxy contract, interface code to enable easy access for dapps, deployment code which calculates what facets to add and remove in each upgrade, etc.","Gemforge to the rescue!","By automating almost all aspects of this boilerplate code whilst still remaining highly configurable, Gemforge lessens the workload and saves time when developing with Diamond Standard.","Gemforge only supports Solidity. Other EVM languages are not currently supported."]},{"i":"who-is-using-gemforge","l":"Who is using Gemforge?","p":["WarMosaic- repo"]}],[{"l":"Getting started"},{"i":"step-1---installation","l":"Step 1 - Installation","p":["Gemforge is written in Node.js and works on all the platforms that Node runs on.","Node v16 or above is required. We recommend using nvm to manage different Node versions on your machine.","It's best to install Gemforge globally in your Node environment, depending on which package manager you use:","At this point you should be able to run the gemforge command:"]},{"i":"step-2---project-setup","l":"Step 2 - Project setup","p":["Gemforge provides example projects to get you started.","These can be cloned and setup in an empty folder using the scaffold command:"]},{"l":"Use with an existing project","p":["If you have an existing Diamond Standard project then you can use the init command to create a Gemforge configuration file.","The gemforge.config.cjs file will have been created in the current folder. You will probably need to edit this file to customize it for your project.","Note: Gemforge assumes that your project uses the diamond-2-hardhat reference repository for the core Diamond Standard libraries. It also assumes that the core facets are part of your diamond."]},{"i":"step-3---build-contracts","l":"Step 3 - Build contracts","p":["To generate all necessary Diamond code and compile your project inside the project folder:"]},{"i":"step-4---deploy-contracts","l":"Step 4 - Deploy contracts","p":["Assuming a local test node is running at http://localhost:8545, use the following to deploy your Diamond code and facets to it:","At this point you've just built and deployed a Diamond Standard project to your local test node using Gemforge!"]},{"i":"step-5---next-steps","l":"Step 5 - Next steps","p":["Add facets and methods","Update the storage structure","Customize initialization"]}],[{"l":"Commands","p":["All Gemforge commands are executed by running gemforge command name in a terminal."]},{"l":"Help","p":["To see list of commands use the --help option:","To see usage help for a particular command type gemforge command name --help. For example:"]},{"l":"Logging","p":["To get verbose logging output, append -v or --verbose to any command, e.g:","To turn off logging completely, append -q or --quiet:","Note: Fatal errors are always logged, even if normal logging is turned off."]}],[{"l":"init","p":["The init command is used initialize a Gemforge configuration file for an existing Diamond standard project of yours.","This will then allow you to run Gemforge commands against said project.","Gemforge assumes that your project uses the diamond-2-hardhat reference repository for the core Diamond Standard libraries. It also assumes that the core facets - DiamondLoupe, DiamondCut, Ownership- are part of your diamond.","To create the default config file:","This will create a file in the current folder called gemforge.config.cjs. You can edit this file to customize the configuration.","To customize the name of the config file, use the --name option:","Note: It's important to keep the .cjs file extension if customizing the config file name, as this is required for Gemforge to be able to load it correctly."]}],[{"l":"scaffold","p":["The scaffold command is used to setup a minimal demo project with Gemforge, as a starting point for one's own project.","This saves you time since everything will already be setup for you to start building with.","To setup the scaffolding in the current folder:","To setup the scaffolding in a specific folder, use the --folder option:","Note: Gemforge will complain if the target folder isn't empty. If it doesn't exist it will be created automatically by Gemforge."]}],[{"l":"build","p":["The build command does all of the following:","Auto-generates Diamond proxy code and Dapp interface.","Auto-generates Diamond deployment code for testing in Foundry.","Builds/compiles all your code.","To run it:","The following files will be generated:","DiamondProxy.sol- the core diamond proxy contract which delegates to all of your facets. The constructor sets up the core library facets, as well as a basic ERC165 implementation.","IDiamondProxy.sol- the diamond proxy interface using which Dapps can execute facet methods on the on-chain contract.","LibDiamondHelper.sol- a library for use within Foundry tests for deploying the Diamond and its facets.","facets.json- a list of all facets and their exported methods - used by the deploy command.","We recommend adding all of the above files to your .gitignore since they are not meant to be committed to version control.","To see an example of the above generated files in action check out the sample project command."]},{"l":"Custom scripts","p":["If you wish to run custom scripts during the build process, then this can be accomplished using hooks. Hooks are custom scripts written in a language of your choice which execute pre- and/or post-build.","See the section on verifying your contracts on Etherscan for an example of hooks in action."]}],[{"l":"deploy","p":["The deploy command both deploys and upgrades Diamond contracts on a network.","If no previous deployment is detected (see below) it will do a new one, otherwise it will automatically work out which facets and methods have changed (by comparing to the on-chain bytecode) and upgrade the on-chain proxy accordingly.","To run it:","This will deploy contracts for the specified target, which must be defined in the targets configuration."]},{"l":"Deployment records","p":["Once deployment has succeeded a gemforge.deployments.json file will be created. This contains the addresses of all the deployed contracts along with their constructor arguments and deployment transaction hashes, for each target that has been deployed to.","An example gemforge.deployments.json:","Subsequent calls to the deploy command with the same target will result in this file being checked to see if a deployment already exists for the given target and can thus be upgraded, or if a new deployment is needed.","When checking for an existing deployment, Gemforge performs a thorough check - i.e. it actually attempts to query the proxy contract on the target's network and to see if it is indeed a Diamond deployment.","In order for upgrades to work, Gemforge assumes that the core facets - DiamondLoupe, DiamondCut, Ownership- are part of your diamond. If you used Gemforge to deploy the initial diamond then this will already be taken care of for you."]},{"l":"Fresh deployments","p":["You can bypass Gemforge's default behaviour and force a fresh deployment of the Diamond using the --new CLI argument:","This will force a new deployment of the Diamond and associated facets, disregarding any existing on-chain Diamond. Existing deployment srecord for the Diamond contract as well as facets will be replaced with new ones.","Sometimes you may simply wish to reset an existing Diamond to a fresh state, i.e. replace all of its selectors with the current facet build output. To do this you can use the --reset argument:","This will remove all non-core facet selectors from the existing on-chain Diamond as a first step, thus causing the current facet contracts to be deployed to the diamond afresh. The existing deployment record for the Diamond contract will remain unchanged, but facet deployment records will be replaced."]},{"l":"Custom scripts","p":["If you wish to run custom scripts during the deployment process, then this can be accomplished using hooks. Hooks are custom scripts written in a language of your choice which execute pre- and/or post-deployment.","See the section on verifying your contracts on Etherscan for an example of hooks in action."]}],[{"l":"Configuration","p":["The Gemforge configuration file - gemforge.config.cjs- tells how Gemforge how to understand your project layout and what actions to take.","The default configuration file template contains all possible configuration options as well as accompanying comments explaining their purpose.","Note: ALL configuration options are mandatory, as this then makes everything explicit, reducing the chance of errors."]}],[{"l":"Compiler","p":["All generated Solidity code will have the following two lines at the top:","Both the SPDX license id and Solidity version to use must be set in the config file:","The SPDX license id must be valid, and will be checked against a known list."]}],[{"l":"Commands","p":["Gemforge executes certain commands via the underlying development framework.","These must be configured as follows:"]}],[{"l":"Paths","p":["Gemforge needs to know where to find your contract source code, library imports, build artifacts, and where to place all generated output.","The configuration options:"]},{"l":"Generated files","p":["The generated.solidity folder path should be inside the same folder containing your project's smart contracts so that everything gets compiled together.","The generated.solidity folder path is for holding files which are used by Gemforge internally.","The generated.deployments file will contain the details of deployed Diamond contracts, indexed by network chain id. You may wish to check this file into version control in order to store these details for consumption elsewhere."]},{"l":"Library files","p":["The lib.diamond folder path should point to where the contents of the diamond-2-hardhat repository can be found. This is required for the code which Gemforge generates."]}],[{"l":"Generator","p":["Generator options modify the behaviour of the code generator."]},{"l":"Proxy interface imports","p":["The generator.proxyInterface.imports array lists files which should be imported within the generated diamond proxy interface code.","For example, you need to use this when dealing with custom structs."]}],[{"l":"Artifacts","p":["Gemforge needs to know the format the artifacts are in:"]}],[{"l":"Diamond","p":["The diamond structure itself can be configured:"]},{"l":"Initialization contract","p":["The initialization contract - diamond.init config - is optional, and is only needed if you wish to execute custom initialization code on-chain when doing a new deployment of your Diamond."]},{"l":"Core facets","p":["Core facets are contracts whose selectors are considered sacrosanct such that they will never be removed from the diamond in upgrade by Gemforge. Gemforge will also complain if you create a contract that has one of these names.","The default core facets in the config file are the ones provided by the standard diamond library and are essential to the correct working of the deployment and upgrade mechanisms:","DiamondLoupe- An interface for querying the diamond. Essential to making upgrades work.","DiamondCut- The upgrade mechanism for the diamond.","Ownership- Verification and transfer of diamond ownership.","Unless you really know what you're doing, we recommend leaving this array unchanged."]}],[{"l":"Hooks","p":["Gemforge makes it easy to run pre- and post- hooks for the build and deploy commands. These can be any command-line call:"]},{"l":"Environment variables","p":["When Gemforge calls the preDeploy and postDeploy hooks it will pass through the following environment variables:","GEMFORGE_DEPLOY_TARGET- target being deployed","GEMFORGE_DEPLOY_CHAIN_ID- chain id of network being deployed to","This can then be used in your hooks, e.g we may define a post-deployment script as follows:","See the section on verifying your contracts on Etherscan for a more detailed example of hooks.","If any of the hook scripts fail to execute properly or throw an error then Gemforge will also throw an error."]}],[{"l":"Wallets","p":["Wallets are required for deploying to a target.","They are configured as follows:","The words config parameter for mnemonic wallets can either be a string of words or a method which returns the same.","Note: At present only the mnemonic wallet type is supported. We aim to add more wallet types in future."]}],[{"l":"Networks","p":["Networks (i.e. chains) are required for deploying to a target.","They are configured as follows:","The rpcUrl value can either be a URL string or a method which returns the same."]}],[{"l":"Security","p":["It's important to keep your configuration file secure by not storing sensitive information inside it. This includes but is not limited to:","Mnemonic / seed phrases used for production deployments","Infura / Alchemy RPC URLs which contain your API key","Any other passwords and/or API keys"]},{"l":"Environment secrets","p":["The default configuration file template gives one example of how this can be accomplished using environment variables. For example:","To make this work you would have to supply the MNEMONIC environment variable on the command-line or in the shell environment. For example:"]},{"i":"env","l":".env","p":["Another option is to use the dotenv package within your config file to load in these environment variables from a .env file:","Then in gemforge.config.cjs:","A working example of this can be seen in the sample project.","Note: Remember to add .env to your .gitignore if you use this method."]}],[{"l":"Targets","p":["Targets are how Gemforge deploys knows how to deploy your contracts.","Each target must specify a network and wallet to use for deployment.","This means you can deploy multiple instances of your Diamond to the same network, where each instance is represented by a different target.","The wallet value must refer to a valid, defined wallet. The initArgs value is only valid if you are customizing the initialization of your diamond.","To deploy contracts to one of the specified targets simply use its name with the deploy command. For example, to deploy to the testnet target:"]}],[{"l":"Development","p":["Once you have the a basic Gemforge project setup and working you can start adding to your Diamond and configuring Gemforge to help you accomplish common tasks."]}],[{"l":"Facets and methods","p":["Gemforge excels at reconciling your current compiled facets and methods with what's on-chain in a Diamond and then making the necessary changes to bring the two into sync.","To ensure things run smoothly we recommend adhering to the following rules:","Each facet should be named anything you wantFacet and be contained in its own file called anything you wantFacet.sol in the same folder as all of your other facet files.","Note: This naming pattern assumes you are using a matching facet source path pattern.","Do NOT use the same facet names as the core facets.","Do NOT use function polymorphism. Instead, ensure every function is uniquely named."]},{"l":"Directory tree","p":["As seen in the demo repos, we recommend the following directory structure inside the folder which contains your contracts:","This wil help keep your code neatly organized and easy to navigate."]},{"i":"shared-code---base-contract","l":"Shared code - base contract","p":["If one or more of your facets share common code it might be worth creating a base contract your facets inherit from. Note that this base contract should ideally be abstract and not follow the same naming scheme as your facet contracts so that Gemforge doesn't think its a facet.","For example:"]},{"i":"shared-code---libraries","l":"Shared code - libraries","p":["Another approach to sharing code between facets is to use non-deployed libraries:"]},{"l":"Facades","p":["Facades are a very powerful abstraction for deploying multiple ERC20s/NFTs/etc. all backed by a single Diamond instance:","The demo projects demonstrate facades using ERC20 tokens. For a more detailed explanation of the workings of facades please see this blog post."]}],[{"l":"App storage","p":["We recommend using the App storage pattern for storing data in a Diamond as this gives the most flexibility and ease-of-use.","The demo projects illustrate this through the LibAppStorage.sol file, which contains something like:","Any contract in your codebase can now load the current diamond storage and interact with the storage variables. For example:"]},{"l":"Modifying storage post-deployment","p":["It goes without saying the types of existing variables in your storage structures should never be removed or modified once the Diamond has been deployed, as this will otherwise cause memory corruption.","But what about adding new variables?","To add storage variables to a deployed Diamond without causing memory corruption, the following rule MUST be adhered to:","A struct may only be extended with new variables by appending them to the end of the list of existing variables, NEVER before or in between existing variables.","And note that this rule also applies to the AppStorage struct itself.","For example, let's say we are storing game results for players playing a game:","Here are the variable additions that are both safe and unsafe to do based on the above rule:"]}],[{"l":"Custom initialization","p":["When deploying a Diamond for the first time, it's possible to run additional initialization code at the end of the cut call, in order to setup your Diamond's internal state.","This is specified as a specific contract and method to call within the configuration file. For example:","We would then create an InitDiamond.sol file somewhere within our source tree, and it must contain the init() method which may or may not take arguments. For this example, let's have a single uint argument:","When deploying to any target we will need to specify the values for the init() method arguments. This allows to specify different initialization parameters (and thus initialize our Diamond different) for different target.","For example, for the above init() method we need to specify one argument:"]}],[{"l":"Custom structs","p":["If any of your facet methods utilise custom structs either as input or output, then you will need to tell Gemforge how to import these structs in the generated diamond proxy interface code.","For example, if you had the following facet file:","Then the proxy interface file generated by Gemforge would contain this method signature.","However, the file wouldn't compile since the struct isn't imported by it:","To fix this, we recommend that you define a file containing all of your custom structs - e.g Structs.sol- and then import that into your facet code. For example:","Now you would modify the config as follows:","The Structs.sol file would then be imported by the generated proxy interface via the correct relative folder path, and the interface code itself would now compile:","For a working example of the above, check out the demo project."]}],[{"l":"Etherscan verification","p":["To verify your contracts on Etherscan you can use post-deploy hooks.","We first need a script to perform the verification. Our requirements:","Load deployment information from the deployment records.","Load deployment network information from the hook environment.","Only verify for public chains, and not local test nodes.","Here is the Foundry example project script:","Inside the Gemforge configuration we then set this script as a post-deploy hook:","And that's it! Every time we deploy, this script will be called.","The GEMFORGE_DEPLOY_TARGET environment variable relied upon by the verification script is set automatically by Gemforge when calling deployment hooks."]}],[{"l":"Supported frameworks","p":["At present the following two Solidity development frameworks are supported:","Foundry- Fast, rust-based. RECOMMENDED.","Hardhat- Javascript/Typescript-based, more plugins.","We recommend Foundry over Hardhat because it's much faster (especially for testing) and allows for tests to be written in Solidity.","Gemforge is built with Foundry primarily in mind. However, sample projects for both frameworks are available:","Foundry: https://github.com/gemstation/contracts-foundry","Hardhat: https://github.com/gemstation/contracts-hardhat","Both sample projects also demonstrate the following:","Custom structs","Etherscan verification","The sample projects both use Git submodules to load in essential third-party libraries."]}],[{"l":"Useful links","p":["Gemforge","Homepage: https://gemforge.xyz","Github repository: https://github.com/gemstation/gemforge","NPM package: https://npmjs.com/package/gemforge","Twitter: https://twitter.com/hiddentao","Diamond Standard","EIP-2535: https://eips.ethereum.org/EIPS/eip-2535","Canonical implementation: https://github.com/mudgen/diamond-2-hardhat/","Documentation: https://www.info.diamonds/","Curated list of stuff: https://github.com/mudgen/awesome-diamonds"]}]]