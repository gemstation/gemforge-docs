[[{"l":"Introduction","p":["Gemforge is an open-source command-line tool for building, deploying and upgrading Diamond Standard contracts on EVM chains."]},{"l":"Why","p":["The Diamond Standard (EIP-2535) is one of the best ways to build and deploy infinite sized, upgradeable contracts.","But utilizing the standard involves having to write a lot of boilerplate code, including but not limited to the core diamond proxy contract, interface code to enable easy access for dapps, deployment code which calculates what facets to add and remove in each upgrade, etc.","Gemforge to the rescue!","By automating almost all aspects of this boilerplate code whilst still remaining highly configurable, Gemforge lessens the workload and saves time when developing with Diamond Standard.","Gemforge only supports Solidity. Other EVM languages are not currently supported."]},{"i":"who-is-using-gemforge","l":"Who is using Gemforge?","p":["Nayms","Tribally Games"]}],[{"l":"Getting started"},{"i":"step-1---installation","l":"Step 1 - Installation","p":["Gemforge is written in Node.js and works on all the platforms that Node runs on.","Node v16 or above is required. We recommend using nvm to manage different Node versions on your machine.","It's best to install Gemforge globally in your Node environment, depending on which package manager you use:","At this point you should be able to run the gemforge command:"]},{"i":"step-2---project-setup","l":"Step 2 - Project setup","p":["Gemforge provides example projects to get you started.","These can be cloned and setup in an empty folder using the scaffold command:"]},{"l":"Use with an existing project","p":["If you have an existing Diamond Standard project then you can use the init command to create a Gemforge configuration file.","The gemforge.config.cjs file will have been created in the current folder. You will probably need to edit this file to customize it for your project.","Note: Gemforge assumes that your project uses the diamond-2-hardhat reference repository for the core Diamond Standard libraries. It also assumes that the core facets are part of your diamond."]},{"i":"step-3---build-contracts","l":"Step 3 - Build contracts","p":["To generate all necessary Diamond code and compile your project inside the project folder:"]},{"i":"step-4---deploy-contracts","l":"Step 4 - Deploy contracts","p":["Assuming a local test node is running at http://localhost:8545, use the following to deploy your Diamond code and facets to it:","At this point you've just built and deployed a Diamond Standard project to your local test node using Gemforge!"]},{"i":"step-5---next-steps","l":"Step 5 - Next steps","p":["Add facets and methods","Update the storage structure","Customize initialization"]}],[{"l":"Commands","p":["All Gemforge commands are executed by running gemforge command name in a terminal."]},{"l":"Help","p":["To see list of commands use the --help option:","To see usage help for a particular command type gemforge command name --help. For example:"]},{"l":"Logging","p":["To get verbose logging output, append -v or --verbose to any command, e.g:","To turn off logging completely, append -q or --quiet:","Note: Fatal errors are always logged, even if normal logging is turned off."]}],[{"l":"init","p":["The init command is used initialize a Gemforge configuration file for an existing Diamond standard project of yours.","This will then allow you to run Gemforge commands against said project.","Gemforge assumes that your project uses the diamond-2-hardhat reference repository for the core Diamond Standard libraries. It also assumes that the core facets - DiamondLoupe, DiamondCut, Ownership- are part of your diamond.","To create the default config file:","This will create a file in the current folder called gemforge.config.cjs. You can edit this file to customize the configuration.","To customize the name of the config file, use the --name option:","Note: It's important to keep the .cjs file extension if customizing the config file name, as this is required for Gemforge to be able to load it correctly."]}],[{"l":"scaffold","p":["The scaffold command is used to setup a minimal demo project with Gemforge, as a starting point for one's own project.","This saves you time since everything will already be setup for you to start building with.","To setup the scaffolding in the current folder:","To setup the scaffolding in a specific folder, use the --folder option:","Note: Gemforge will complain if the target folder isn't empty. If it doesn't exist it will be created automatically by Gemforge."]}],[{"l":"build","p":["The build command does all of the following:","Auto-generates Diamond proxy code and Dapp interface.","Auto-generates Diamond deployment code for testing in Foundry.","Builds/compiles all your code.","To run it:","The following files will be generated:","DiamondProxy.sol- the core diamond proxy contract which delegates to all of your facets. The constructor sets up the core library facets, as well as a basic ERC165 implementation.","IDiamondProxy.sol- the diamond proxy interface using which Dapps can execute facet methods on the on-chain contract.","LibDiamondHelper.sol- a library for use within Foundry tests for deploying the Diamond and its facets.","abi.json- a unified ABI consisting of IDiamondProxy exports, custom errors and events. This is needed for when interacting with the Diamond.","facets.json- a list of all facets and their exported methods - used by the deploy command.","We recommend adding all of the above files to your .gitignore since they are not meant to be committed to version control.","To see an example of the above generated files in action check out the sample project command."]},{"l":"Custom scripts","p":["If you wish to run custom scripts during the build process, then this can be accomplished using hooks. Hooks are custom scripts written in a language of your choice which execute pre- and/or post-build.","See the section on verifying your contracts on Etherscan for an example of hooks in action."]}],[{"l":"deploy","p":["The deploy command both deploys and upgrades Diamond contracts on a network.","If no previous deployment is detected (see below) it will do a new one, otherwise it will automatically work out which facets and methods have changed (by comparing to the on-chain bytecode) and upgrade the on-chain proxy accordingly.","To run it:","This will deploy contracts for the specified target, which must be defined in the targets configuration."]},{"l":"Deployment records","p":["Once deployment has succeeded a gemforge.deployments.json file will be created. This contains the addresses of all the deployed contracts along with their constructor arguments and deployment transaction hashes, for each target that has been deployed to.","An example gemforge.deployments.json:","Subsequent calls to the deploy command with the same target will result in this file being checked to see if a deployment already exists for the given target and can thus be upgraded, or if a new deployment is needed.","When checking for an existing deployment, Gemforge performs a thorough check - i.e. it actually attempts to query the proxy contract on the target's network and to see if it is indeed a Diamond deployment.","In order for upgrades to work, Gemforge assumes that the core facets - DiamondLoupe, DiamondCut, Ownership- are part of your diamond. If you used Gemforge to deploy the initial diamond then this will already be taken care of for you."]},{"l":"Fresh deployments","p":["You can bypass Gemforge's default behaviour and force a fresh deployment of the Diamond using the --new CLI argument:","This will force a new deployment of the Diamond and associated facets, disregarding any existing on-chain Diamond. Existing deployment records for the Diamond contract as well as facets will be replaced with new ones.","Sometimes you may simply wish to reset an existing Diamond to a fresh state, i.e. replace all of its selectors with the current facet build output. To do this you can use the --reset argument:","This will remove all non-core facet selectors from the existing on-chain Diamond as a first step, thus causing the current facet contracts to be deployed to the diamond afresh. The existing deployment record for the Diamond contract will remain unchanged, but facet deployment records will be replaced."]},{"l":"Custom upgrade initializations","p":["Sometimes it's useful to be able to run \"initialization\" code during an upgrade of your existing Diamond, similar to the code that gets run during a fresh deployment.","To accomplish this with --upgrade-init-* parameters can be used:","Gemforge will automatically check the passed-in details, deploy the named contract, and then execute the named method within the context of the Diamond. Note that the contract method must not take any arguments.","You can \"upgrade\" your Diamond and run upgrade initialization code even if you're not making any changes to the facets!"]},{"l":"Dry runs","p":["Sometimes you may want to see what a deployment would do without actually going through with it. This is known as a dry deployment and can be actioned using the --dry option. For example:","No actual deployments will take place but Gemforge will still output useful logging to tell you what it would do.","The dry deployment option also works for when doing upgrades, resetting a diamond or doing a fresh deployment to the target."]},{"l":"Pause and resume","p":["When doing deployments it's possible to pause the flow and save the state to file, to be resumed later. This is useful if e.g you have a custom authentication flow which requires you to approve upgrades.","To pause a deployment:","Running this command will deploy all the proxy and facet contracts, but the diamondCut() method will not be called. The cut.json file will contain the array of facet cuts that would be passed to the proxy to complete the deployment/upgrade, e.g:","To resume the deployment at any point, run:","Note: Post-build hooks will only be called if the resume step succeeds. These hooks will not be called for the pause step."]},{"l":"Custom scripts","p":["If you wish to run custom scripts during the deployment process, then this can be accomplished using hooks. Hooks are custom scripts written in a language of your choice which execute pre- and/or post-deployment.","See the section on verifying your contracts on Etherscan for an example of hooks in action."]}],[{"l":"query","p":["The query command outputs the facet configuration of an existing Diamond contract on a network.","To run it:","This will query the deployment records to find the currently deployed contracts for the specified target which must be defined in the targets configuration.","It then matches the on-chain facet and selector information to the current built contract artifacts. For any facets and functions which are not recognized it will note this in the final output.","The output will look something like:","For any unrecognized facets and/or functions the label unknown will be used in the output, e.g:"]},{"l":"JSON output","p":["A JSON version of the result can be obtained using the --json CLI option. This will produce output similar to:"]},{"l":"Output to file","p":["You can have the command write the query output to a file using the --output file option.","For example:","The output of the command (without the Gemforge logging) will now be contained in JSON format in ./query-result.txt."]}],[{"l":"Configuration","p":["The Gemforge configuration file - gemforge.config.cjs- tells how Gemforge how to understand your project layout and what actions to take.","The default configuration file template contains all possible configuration options as well as accompanying comments explaining their purpose.","Note: ALL configuration options are mandatory, as this then makes everything explicit, reducing the chance of errors."]}],[{"l":"Compiler","p":["All generated Solidity code will have the following two lines at the top:","Both the SPDX license id and Solidity version to use must be set in the config file:","The SPDX license id must be valid, and will be checked against a known list."]}],[{"l":"Commands","p":["Gemforge executes certain commands via the underlying development framework.","These must be configured as follows:"]}],[{"l":"Paths","p":["Gemforge needs to know where to find your contract source code, library imports, build artifacts, and where to place all generated output.","The configuration options:"]},{"l":"Generated files","p":["The generated.solidity folder path should be inside the same folder containing your project's smart contracts so that everything gets compiled together.","The generated.solidity folder path is for holding files which are used by Gemforge internally.","The generated.deployments file will contain the details of deployed Diamond contracts, indexed by network chain id. You may wish to check this file into version control in order to store these details for consumption elsewhere."]},{"l":"Library files","p":["The lib.diamond folder path should point to where the contents of the diamond-2-hardhat repository can be found. This is required for the code which Gemforge generates."]}],[{"l":"Generator","p":["Generator options modify the behaviour of the code generator."]},{"l":"Proxy template","p":["By default Gemforge uses its own DiamondProxy.sol template to generate the final proxy contract code.","However, advanced users may wish to have more control, including using custom upgrade facets. In these cases, set the generator.proxy.template key to point to a custom template file to use instead of the default.","We recommend basing custom proxy templates on the Gemforge default one and making only the necessary modifications. Examples can be found in the Gemforge test codebase.","Please be careful when using a custom proxy template. Gemforge expects various default facets and methods to be present on a deployed Diamond in order to be able to query it and perform upgrades successfully."]},{"l":"Proxy interface imports","p":["The generator.proxyInterface.imports array lists files which should be imported within the generated diamond proxy interface code.","For example, you need to use this when dealing with custom structs."]}],[{"l":"Artifacts","p":["Gemforge needs to know the format the artifacts are in:"]}],[{"l":"Diamond","p":["The diamond structure itself can be configured:"]},{"l":"Initialization contract","p":["The initialization contract - diamond.init config - is optional, and is only needed if you wish to execute custom initialization code on-chain when doing a new deployment of your Diamond."]},{"l":"Core facets","p":["Core facets are contracts whose selectors are considered sacrosanct such that they will never be removed from the diamond in upgrade by Gemforge. Gemforge will also complain if you create a contract that has one of these names.","The default core facets in the config file are the ones provided by the standard diamond library and are essential to the correct working of the deployment and upgrade mechanisms:","DiamondLoupe- An interface for querying the diamond. Essential to making upgrades work.","DiamondCut- The upgrade mechanism for the diamond.","Ownership- Verification and transfer of diamond ownership.","Unless you really know what you're doing, we recommend leaving this array unchanged."]}],[{"l":"Hooks","p":["Gemforge makes it easy to run pre- and post- hooks for the build and deploy commands. These can be any command-line call:"]},{"l":"Environment variables","p":["When Gemforge calls the preDeploy and postDeploy hooks it will pass through the following environment variables:","GEMFORGE_DEPLOY_TARGET- target being deployed","GEMFORGE_DEPLOY_CHAIN_ID- chain id of network being deployed to","This can then be used in your hooks, e.g we may define a post-deployment script as follows:","See the section on verifying your contracts on Etherscan for a more detailed example of hooks.","If any of the hook scripts fail to execute properly or throw an error then Gemforge will also throw an error."]}],[{"l":"Wallets","p":["Wallets are required for deploying to a target.","They are configured as follows:","The words config parameter for mnemonic wallets can either be a string of words or a method which returns the same, e.g:","The same applies to the key config parameter for private-key wallets:"]}],[{"l":"Networks","p":["Networks (i.e. chains) are required for deploying to a target.","They are configured as follows:","The rpcUrl value can either be a URL string or a method which returns the same."]}],[{"l":"Security","p":["It's important to keep your configuration file secure by not storing sensitive information inside it. This includes but is not limited to:","Mnemonic / seed phrases used for production deployments","Infura / Alchemy RPC URLs which contain your API key","Any other passwords and/or API keys"]},{"l":"Environment secrets","p":["The default configuration file template gives one example of how this can be accomplished using environment variables. For example:","To make this work you would have to supply the MNEMONIC environment variable on the command-line or in the shell environment. For example:"]},{"i":"env","l":".env","p":["Another option is to use the dotenv package within your config file to load in these environment variables from a .env file:","Then in gemforge.config.cjs:","A working example of this can be seen in the sample project.","Note: Remember to add .env to your .gitignore if you use this method."]}],[{"l":"Targets","p":["Targets are how Gemforge deploys knows how to deploy your contracts.","Each target must specify a network and wallet to use for deployment.","This means you can deploy multiple instances of your Diamond to the same network, where each instance is represented by a different target.","The wallet value must refer to a valid, defined wallet. The initArgs value is only valid if you are customizing the initialization of your diamond.","To deploy contracts to one of the specified targets simply use its name with the deploy command. For example, to deploy to the testnet target:"]},{"l":"CREATE3 salt","p":["The create3Salt value is a 0x prefixed hex string of length 66 that is to be used for keyless CREATE3 deployments of the Diamond proxy contract.","By setting this value you can ensure that your Diamond proxy contract is always deployed to the same address as long as the deployment wallet and salt value remain unchanged. And by using the same wallet and salt for every deployment target you can ensure that all deployments to all targets (and thus chains) are at the same address, making managing omni-chain deployments easy.","If the salt value is empty or ommitted then Gemforge will create a random salt to use, meaning that fresh deployments of your Diamond proxy will always be at different addresses.","Note: Only the Diamond proxy contract is deployed using CREATE3. Facet contracts are deployed normally."]}],[{"l":"Development","p":["Once you have the a basic Gemforge project setup and working you can start adding to your Diamond and configuring Gemforge to help you accomplish common tasks."]}],[{"l":"Facets and methods","p":["Gemforge excels at reconciling your current compiled facets and methods with what's on-chain in a Diamond and then making the necessary changes to bring the two into sync.","To ensure things run smoothly we recommend adhering to the following rules:","Each facet should be named anything you wantFacet and be contained in its own file called anything you wantFacet.sol in the same folder as all of your other facet files.","Note: This naming pattern assumes you are using a matching facet source path pattern.","Function polymorphism is only supported for functions which don't have any struct parameters ( read more)."]},{"l":"Directory tree","p":["As seen in the demo repos, we recommend the following directory structure inside the folder which contains your contracts:","This wil help keep your code neatly organized and easy to navigate."]},{"l":"Core facets","p":["You can override core facets with your own, in case you need to customize the default upgrade and ownership mechanisms.","Be very careful when doing this, however, as you do not want to introduce bugs which disrupt either of these critical mechanisms.","For saftey reasons, Gemforge will not remove methods from core facets. They can only be added or replaced. To remove an old core facet method simply replace it with a dummy method with the same function signature."]},{"i":"shared-code---base-contract","l":"Shared code - base contract","p":["If one or more of your facets share common code it might be worth creating a base contract your facets inherit from. Note that this base contract should ideally be abstract and not follow the same naming scheme as your facet contracts so that Gemforge doesn't think its a facet.","For example:"]},{"i":"shared-code---libraries","l":"Shared code - libraries","p":["Another approach to sharing code between facets is to use non-deployed libraries:"]},{"l":"Facades","p":["Facades are a very powerful abstraction for deploying multiple ERC20s/NFTs/etc. all backed by a single Diamond instance:","The demo projects demonstrate facades using ERC20 tokens. For a more detailed explanation of the workings of facades please see this blog post."]}],[{"l":"App storage","p":["We recommend using the App storage pattern for storing data in a Diamond as this gives the most flexibility and ease-of-use.","The demo projects illustrate this through the LibAppStorage.sol file, which contains something like:","Any contract in your codebase can now load the current diamond storage and interact with the storage variables. For example:"]},{"l":"Modifying storage post-deployment","p":["It goes without saying the types of existing variables in your storage structures should never be removed or modified once the Diamond has been deployed, as this will otherwise cause memory corruption.","But what about adding new variables?","To add storage variables to a deployed Diamond without causing memory corruption, the following rule MUST be adhered to:","A struct may only be extended with new variables by appending them to the end of the list of existing variables, NEVER before or in between existing variables.","And note that this rule also applies to the AppStorage struct itself.","For example, let's say we are storing game results for players playing a game:","Here are the variable additions that are both safe and unsafe to do based on the above rule:"]}],[{"l":"Initialization","p":["When deploying a Diamond for the first time, it's possible to run additional initialization code at the end of the cut call, in order to setup your Diamond's internal state.","This is specified as a specific contract and method to call within the configuration file. For example:","We would then create an InitDiamond.sol file somewhere within our source tree, and it must contain the init() method which may or may not take arguments. For this example, let's have a single uint argument:","When deploying to any target we will need to specify the values for the init() method arguments. This allows to specify different initialization parameters (and thus initialize our Diamond different) for different target.","For example, for the above init() method we need to specify one argument:"]},{"l":"Initialization during an upgrade","p":["Sometimes you may wish to run some initialization code during an upgrade. To do this you can use the --upgrade-init-* parameters as follows:","Gemforge will automatically check the passed-in details, deploy the named contract, and then execute the named method within the context of the Diamond. Note: It is expected that the contract method takes no arguments.","We recommend placing such upgrade initialization code within the init subfolder, alongside your initialization code for fresh deployments:","We recommend that you use storage variables to keep track of whether a given upgrade initialization code has previously been executed. This will ensure you can't run the same code twice, thereby preventing any mistakes. For example:"]}],[{"l":"Custom structs","p":["If any of your facet methods utilise custom structs either as input or output, then you will need to tell Gemforge how to import these structs in the generated diamond proxy interface code.","For example, if you had the following facet file:","Then the proxy interface file generated by Gemforge would contain this method signature.","However, the file wouldn't compile since the struct isn't imported by it:","To fix this, we recommend that you define a file containing all of your custom structs - e.g Structs.sol- and then import that into your facet code. For example:","Now you would modify the config as follows:","The Structs.sol file would then be imported by the generated proxy interface via the correct relative folder path, and the interface code itself would now compile:","For a working example of the above, check out the demo project."]}],[{"l":"Etherscan verification","p":["To verify your contracts on Etherscan you can use post-deploy hooks.","We first need a script to perform the verification. Our requirements:","Load deployment information from the deployment records.","Load deployment network information from the hook environment.","Only verify for public chains, and not local test nodes.","Here is the Foundry example project script:","Inside the Gemforge configuration we then set this script as a post-deploy hook:","And that's it! Every time we deploy, this script will be called.","The GEMFORGE_DEPLOY_TARGET environment variable relied upon by the verification script is set automatically by Gemforge when calling deployment hooks."]}],[{"l":"ABI generation","p":["The build command will auto-generate an ABI for the Diamond. The ABI will be stored in abi.json, next to the generated Diamond proxy code.","This ABI contains all of the functions exported in the Diamond proxy interface as well as any and all custom errors and events found in all the compiled artifacts (including imported libraries).","This allows front-end libraries such as such as Wagmi to recognize and decode errors and events emitted by your Diamond."]}],[{"l":"Omni-chain addresses","p":["Gemforge uses CREATE3 keyless deployment under the hood to deploy the Diamond proxy contract.","This makes it possible to deploy the Diamond proxy to the same address on every chain, as long as you are using the same wallet and CREATE3 salt to deploy each target.","As an example, let's say we are deploying to two targets - mainnet and base. The target configurations will look something like:","If we do fresh deployments to both of these targets the Diamond proxy should have the same contract address on both, regardless of the difference in wallet1's activity on each chain.","If you attempt to do a fresh deployment on a chain which already has a deployment using the same wallet and salt then Gemforge will complain that the address is already in use and that you should change the salt value."]},{"l":"CREATE3 factory","p":["Gemforge uses the CREATE3 factory from the SKYBIT-Keyless-Deployment repository.","Here are the details:","The deployed address of the factory on every chain: 0x24fCFA23F3b22c15070480766E3fE2fad3E813EA","The deploying wallet's public key: 0xc7c0A9dc9c997438eE834bb155dF2AF7fDAe6073","Deployment gas limit: 350,000","Deployment gas price: 100 gwei(= 100000000000 wei or 0.0000001 eth)","Funds required to deploy: 0.035 eth(= gas limit * gas price)","You can deploy the factory yourself on a new chain please ensure there are enough funds in the deploying wallet and then send the following raw signed transaction to the chain:","The ABI of the deployed factory is:"]}],[{"l":"Simulating upgrades","p":["When doing upgrades in production (e.g on Mainnet) it would be prudent to first simulate the upgrade prior to running the live operation.","Although Gemforge allows for \"dry\" deployments these simply list what actions Gemforge would take during a real deployment. To actually understand what changes would be made to the chain you need to fork the chain locally and run the deployment command against this local copy.","Thankfully, forking a chain to test against locally is easily accomplished (Forge docs, Hardhat docs)."]},{"i":"example-simulating-a-mainnet-upgrade","l":"Example: Simulating a Mainnet upgrade","p":["This example assumes the following:","You've previously deployed your Diamond to Mainnet using Gemforge and that the contract address is saved in gemforge.deployments.json.","You are using Alchemy and have your Alchemy API key set in the shell environment as ALCHEMY_API_KEY(The example works equally well with Infura and/or other node services).","Let's say you have your Mainnet deployment target configured in Gemforge as follows:","Add another entry for the local Mainnet fork using the same config parameters:","Now edit the gemforge.deployments.json file and duplicate the mainnet target entries for mainnetFork:","Now start a local fork of Mainnet:","Now you can run the upgrade against the local fork:","That's it! You've just run simulated your Mainnet upgrade locally. You can inspect the locally running fork to see what changes the upgrade made."]}],[{"l":"Useful links","p":["Gemforge","Homepage: https://gemforge.xyz","Github repository: https://github.com/gemstation/gemforge","NPM package: https://npmjs.com/package/gemforge","Twitter: https://twitter.com/hiddentao","Diamond Standard","EIP-2535: https://eips.ethereum.org/EIPS/eip-2535","Canonical implementation: https://github.com/mudgen/diamond-2-hardhat/","Documentation: https://www.info.diamonds/","Curated list of stuff: https://github.com/mudgen/awesome-diamonds"]}],[{"l":"Supported frameworks","p":["At present the following two Solidity development frameworks are supported:","Foundry- Fast, rust-based. RECOMMENDED.","Hardhat- Javascript/Typescript-based, more plugins.","We recommend Foundry over Hardhat because it's much faster (especially for testing) and allows for tests to be written in Solidity.","Gemforge is built with Foundry primarily in mind. However, sample projects for both frameworks are available:","Foundry: https://github.com/gemstation/contracts-foundry","Hardhat: https://github.com/gemstation/contracts-hardhat","Both sample projects also demonstrate the following:","Custom structs","Etherscan verification","The sample projects both use Git submodules to load in essential third-party libraries."]}]]